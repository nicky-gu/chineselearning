<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒŸ å¿«ä¹å­¦æ±‰å­— ğŸŒŸ</title>
    <script src="https://cdn.jsdelivr.net/npm/pinyin-pro@3.18.2/dist/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            animation: bounceIn 0.8s ease;
        }

        @keyframes bounceIn {
            0% { transform: scale(0.3); opacity: 0; }
            50% { transform: scale(1.05); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); opacity: 1; }
        }

        header h1 {
            font-size: 2.5em;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.3);
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .card {
            background: white;
            border-radius: 20px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            animation: slideUp 0.6s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .input-section h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
            text-align: center;
        }

        #charInput {
            width: 100%;
            padding: 18px;
            font-size: 1.3em;
            border: 3px solid #ddd;
            border-radius: 15px;
            text-align: center;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }

        #charInput:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
        }

        .section-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: #f0f0f0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.95em;
            font-weight: bold;
            color: #666;
        }

        .tab-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab-btn:hover {
            transform: scale(1.05);
        }

        .practice-section {
            display: none;
        }

        .practice-section.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .section-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .section-title h2 {
            color: #667eea;
            font-size: 1.5em;
        }

        .action-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-danger {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: scale(1.05);
        }

        /* æ‹¼éŸ³å­¦ä¹ æ ·å¼ */
        .pinyin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
        }

        .pinyin-card {
            background: linear-gradient(135deg, #ffeaa7 0%, #fdcb6e 100%);
            border-radius: 15px;
            padding: 18px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .pinyin-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .pinyin-card .text {
            font-size: 2.5em;
            font-weight: bold;
            color: #2d3436;
            margin-bottom: 8px;
        }

        .pinyin-card .pinyin-hint {
            font-size: 1.3em;
            color: #636e72;
        }

        /* ç»ƒä¹ æœ¬æ ·å¼ */
        .practice-book {
            background: #fff9e6;
            border-radius: 15px;
            padding: 20px;
            margin-top: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .practice-char {
            display: flex;
            align-items: center;
            padding: 12px;
            margin-bottom: 12px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .practice-char .big-char {
            font-size: 2.5em;
            width: 70px;
            text-align: center;
            margin-right: 15px;
            color: #667eea;
        }

        .practice-char .pinyin-display {
            font-size: 1.3em;
            color: #636e72;
            margin-right: 15px;
            min-width: 90px;
        }

        .practice-char .practice-input {
            flex: 1;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .practice-char .practice-input input {
            padding: 8px 12px;
            font-size: 1em;
            border: 2px solid #ddd;
            border-radius: 10px;
            min-width: 100px;
        }

        .practice-char .practice-input input:focus {
            outline: none;
            border-color: #667eea;
        }

        .practice-char .practice-input input.correct {
            border-color: #11998e;
            background: #d4edda;
        }

        .practice-char .practice-input input.wrong {
            border-color: #eb3349;
            background: #f8d7da;
        }

        .practice-char .play-btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .practice-char .play-btn:hover {
            background: #764ba2;
            transform: scale(1.05);
        }

        .practice-instruction {
            background: #e3f2fd;
            padding: 12px;
            border-radius: 10px;
            margin-bottom: 15px;
            color: #1976d2;
            font-size: 0.95em;
        }

        /* ç»Ÿè®¡æ ·å¼ */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .stat-card .number {
            font-size: 2.5em;
            font-weight: bold;
            color: #2d3436;
            margin-bottom: 5px;
        }

        .stat-card .label {
            font-size: 1em;
            color: #636e72;
        }

        .mistake-list {
            margin-top: 20px;
        }

        .mistake-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: #fff5f5;
            border-radius: 10px;
            margin-bottom: 10px;
            border-left: 4px solid #eb3349;
        }

        .mistake-item .char {
            font-size: 1.5em;
            color: #2d3436;
            font-weight: bold;
        }

        .mistake-item .info {
            font-size: 0.9em;
            color: #666;
            margin-left: 10px;
        }

        .mistake-item .remove-btn {
            background: #eb3349;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85em;
            transition: all 0.3s ease;
        }

        .mistake-item .remove-btn:hover {
            transform: scale(1.05);
        }

        /* å¬éŸ³é€‰å­—æ ·å¼ */
        .sound-game {
            text-align: center;
        }

        .game-progress {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 20px;
            font-size: 1.2em;
            color: #666;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            transition: width 0.5s ease;
        }

        .sound-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            font-size: 2.5em;
            cursor: pointer;
            margin: 15px auto;
            display: block;
            transition: all 0.3s ease;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .sound-btn:hover:not(:disabled) {
            transform: scale(1.1);
            box-shadow: 0 15px 40px rgba(102, 126, 234, 0.6);
        }

        .sound-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .option-btn {
            padding: 25px;
            font-size: 2em;
            border: 3px solid #ddd;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .option-btn:hover:not(:disabled) {
            border-color: #667eea;
            background: #f8f9ff;
            transform: scale(1.02);
        }

        .option-btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .option-btn.correct {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            border-color: #11998e;
            animation: pulse 0.5s ease;
        }

        .option-btn.wrong {
            background: linear-gradient(135deg, #eb3349 0%, #f45c43 100%);
            color: white;
            border-color: #eb3349;
            animation: shake 0.5s ease;
        }

        /* å­—è¯é€‰æ‹©æ ·å¼ */
        .word-checkbox:hover {
            border-color: #667eea !important;
            background: #f8f9ff !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(102, 126, 234, 0.2);
        }

        .word-checkbox:has(input:checked) {
            border-color: #11998e;
            background: #f0fff9;
        }

        /* æ‹¼éŸ³é€‰é¡¹æŒ‰é’®æ ·å¼ */
        .pinyin-option-btn:hover:not(:disabled) {
            border-color: #667eea;
            background: #f8f9ff;
            transform: translateY(-2px);
        }

        .pinyin-option-btn:disabled {
            cursor: not-allowed;
            opacity: 0.7;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        /* ç»“æœæ˜¾ç¤º */
        .result-box {
            text-align: center;
            padding: 30px;
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            border-radius: 15px;
            margin-top: 20px;
        }

        .result-box .score {
            font-size: 3em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
        }

        .result-box .message {
            font-size: 1.5em;
            color: #2d3436;
            margin-bottom: 20px;
        }

        .result-box .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 25px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: scale(1.05);
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .empty-state .emoji {
            font-size: 3em;
            margin-bottom: 15px;
        }

        footer {
            text-align: center;
            color: white;
            margin-top: 20px;
            opacity: 0.8;
            font-size: 0.9em;
        }

        /* ç™»å½•æ¨¡æ€æ¡†æ ·å¼ */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        .modal h2 {
            color: #667eea;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.5em;
        }

        .modal p {
            color: #666;
            margin-bottom: 15px;
            text-align: center;
            font-size: 0.95em;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            color: #666;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .form-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 10px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group input::-webkit-outer-spin-button,
        .form-group input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .form-group input[type=number] {
            -moz-appearance: textfield;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-buttons button {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: scale(1.05);
        }

        .btn-secondary {
            background: #f0f0f0;
            color: #666;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
        }

        .error-message {
            color: #eb3349;
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .success-message {
            color: #11998e;
            text-align: center;
            margin-top: 10px;
            font-size: 0.9em;
        }

        /* åŒæ­¥æŒ‰é’®æ ·å¼ */
        .sync-section {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .sync-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 0.95em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sync-btn:hover {
            transform: scale(1.05);
        }

        .sync-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .sync-status {
            font-size: 0.9em;
            color: #666;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .sync-status.synced {
            color: #11998e;
        }

        .sync-status.syncing {
            color: #667eea;
        }

        .sync-status.error {
            color: #eb3349;
        }

        .sync-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
        }

        .sync-status.synced .sync-status-dot {
            background: #11998e;
        }

        .sync-status.syncing .sync-status-dot {
            background: #667eea;
            animation: pulse 1s infinite;
        }

        .sync-status.error .sync-status-dot {
            background: #eb3349;
        }

        .user-info {
            text-align: center;
            padding: 10px;
            background: #f0f8ff;
            border-radius: 10px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #666;
        }

        .user-info .username {
            font-weight: bold;
            color: #667eea;
        }

        .logout-link {
            color: #eb3349;
            cursor: pointer;
            text-decoration: underline;
        }

        .logout-link:hover {
            color: #c0392b;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.8em;
            }

            .pinyin-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .options-grid {
                grid-template-columns: 1fr;
            }

            .practice-char {
                flex-direction: column;
                align-items: flex-start;
            }

            .practice-char .big-char,
            .practice-char .pinyin-display {
                margin-right: 0;
                margin-bottom: 8px;
            }

            .section-tabs {
                gap: 5px;
            }

            .tab-btn {
                padding: 8px 15px;
                font-size: 0.85em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸŒŸ å¿«ä¹å­¦æ±‰å­— ğŸŒŸ</h1>
            <p>è¾“å…¥å­—æˆ–è¯ç»„ï¼Œç”¨ç©ºæ ¼æˆ–é€—å·åˆ†éš”ï¼Œå¼€å§‹ç»ƒä¹ å§ï¼</p>
            <div id="userInfoSection" style="display: none;">
                <div class="user-info">
                    <span>å·²ç™»å½•äº‘ç«¯åŒæ­¥</span>
                    <span class="logout-link" onclick="handleLogout()">é€€å‡ºç™»å½•</span>
                </div>
                <div class="sync-section">
                    <div class="sync-status" id="syncStatus">
                        <div class="sync-status-dot"></div>
                        <span id="syncStatusText">æœªåŒæ­¥</span>
                    </div>
                    <button class="sync-btn" onclick="manualSync()" id="syncBtn">
                        <span>ğŸ”„</span>
                        <span>åŒæ­¥æ•°æ®</span>
                    </button>
                </div>
            </div>
            <div id="loginPrompt" style="text-align: center; margin-top: 15px;">
                <button class="btn-primary" onclick="openLoginModal()" style="padding: 10px 25px; border: none; border-radius: 20px; font-size: 1em; font-weight: bold; cursor: pointer; background: rgba(255,255,255,0.2); color: white; transition: all 0.3s ease;">
                    ğŸ” ç™»å½•åŒæ­¥æ•°æ®
                </button>
            </div>
        </header>

        <div class="card input-section">
            <h2>âœï¸ è¾“å…¥æ±‰å­—</h2>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                <input type="text" id="charInput" placeholder="è¾“å…¥å­—æˆ–è¯ç»„ï¼Œç”¨ç©ºæ ¼æˆ–é€—å·åˆ†éš”" maxlength="100" style="flex: 1;">
                <button onclick="addInput()" class="action-btn" style="background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); color: white; padding: 12px 25px; white-space: nowrap; border: none;">
                    â• æ·»åŠ 
                </button>
                <button onclick="clearInput()" class="action-btn" style="background: #f0f0f0; color: #666; padding: 12px 20px; white-space: nowrap; border: none;">
                    æ¸…ç©ºè¾“å…¥
                </button>
            </div>
            <div id="addedWordsPreview" style="min-height: 30px; padding: 10px; background: #f8f9ff; border-radius: 10px; font-size: 0.9em; color: #666; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <span style="font-weight: bold; color: #667eea;">å·²æ·»åŠ :</span> <span id="addedWordsList"></span>
                    </div>
                    <button onclick="clearAll()" class="action-btn" style="background: #fff; color: #eb3349; padding: 6px 12px; font-size: 0.85em; border: 1px solid #eb3349;">
                        æ¸…ç©ºå…¨éƒ¨
                    </button>
                </div>
            </div>
            <div class="section-tabs">
                <button class="tab-btn" data-tab="practice">âœï¸ çœ‹å­—é€‰æ‹¼éŸ³</button>
                <button class="tab-btn" data-tab="sound">ğŸ‘‚ å¬éŸ³é€‰å­—</button>
                <button class="tab-btn" data-tab="mistakes">âŒ é”™é¢˜é›†</button>
                <button class="tab-btn active" data-tab="stats">ğŸ“Š ç»Ÿè®¡</button>
            </div>
        </div>

        <!-- ç»ƒä¹ æœ¬ -->
        <div class="card practice-section" id="practice-section">
            <div class="section-title">
                <h2>âœï¸ çœ‹å­—é€‰æ‹¼éŸ³</h2>
            </div>
            <div id="practice-content">
                <div class="empty-state">
                    <div class="emoji">ğŸ“–</div>
                    <p>è¯·å…ˆè¾“å…¥å­—æˆ–è¯ç»„</p>
                </div>
            </div>
        </div>

        <!-- å¬éŸ³é€‰å­— -->
        <div class="card practice-section" id="sound-section">
            <div class="section-title">
                <h2>ğŸ‘‚ å¬éŸ³é€‰å­—</h2>
            </div>
            <div id="sound-content">
                <div class="empty-state">
                    <div class="emoji">ğŸ®</div>
                    <p>è¯·è‡³å°‘è¾“å…¥2ä¸ªå­—æˆ–è¯ç»„ï¼Œç„¶åå¼€å§‹æ¸¸æˆ</p>
                </div>
            </div>
        </div>

        <!-- é”™é¢˜é›† -->
        <div class="card practice-section" id="mistakes-section">
            <div class="section-title">
                <h2>âŒ é”™é¢˜é›†</h2>
                <button class="action-btn btn-danger" onclick="clearMistakes()">æ¸…ç©ºé”™é¢˜é›†</button>
            </div>
            <div id="mistakes-content">
                <div class="empty-state">
                    <div class="emoji">âœ¨</div>
                    <p>æš‚æ—¶æ²¡æœ‰é”™é¢˜ï¼Œç»§ç»­åŠ æ²¹ï¼</p>
                </div>
            </div>
        </div>

        <!-- ç»Ÿè®¡ -->
        <div class="card practice-section active" id="stats-section">
            <div class="section-title">
                <h2>ğŸ“Š å­¦ä¹ ç»Ÿè®¡</h2>
                <button class="action-btn btn-danger" onclick="clearStats()">æ¸…ç©ºæ•°æ®</button>
            </div>
            <p style="color: #666; margin-bottom: 15px;">ğŸ’¾ æ•°æ®è‡ªåŠ¨ä¿å­˜åœ¨æµè§ˆå™¨ä¸­ï¼Œä¸‹æ¬¡æ‰“å¼€è¿˜åœ¨</p>
            <div id="stats-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="number" id="totalLearned">0</div>
                        <div class="label">å·²å­¦å­—è¯</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="totalPractice">0</div>
                        <div class="label">ç»ƒä¹ æ¬¡æ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="correctRate">0%</div>
                        <div class="label">æ­£ç¡®ç‡</div>
                    </div>
                    <div class="stat-card">
                        <div class="number" id="mistakeCount">0</div>
                        <div class="label">é”™å­—æ•°é‡</div>
                    </div>
                </div>
                <div id="learnedWordsList" style="margin-top: 20px;"></div>
            </div>
        </div>

        <footer>
            <p>ğŸ’– ç”¨å¿ƒé™ªä¼´å­©å­çš„æ¯ä¸€æ¬¡å­¦ä¹  ğŸ’–</p>
        </footer>

        <!-- ç™»å½•æ¨¡æ€æ¡† -->
        <div class="modal-overlay" id="loginModal">
            <div class="modal">
                <h2 id="modalTitle">ğŸ” ç™»å½• / æ³¨å†Œ</h2>
                <p>è¾“å…¥8ä½PINç æ¥åŒæ­¥å­¦ä¹ æ•°æ®</p>
                <div class="form-group">
                    <label for="pinInput">8ä½PINç </label>
                    <input type="number" id="pinInput" placeholder="è¾“å…¥8ä½æ•°å­—" maxlength="8" min="0" max="99999999">
                </div>
                <div id="loginMessage"></div>
                <div class="modal-buttons">
                    <button class="btn-secondary" onclick="closeLoginModal()">å–æ¶ˆ</button>
                    <button class="btn-primary" onclick="handleLogin()">ç™»å½• / æ³¨å†Œ</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ•°æ®å­˜å‚¨
        let currentChars = [];
        // åˆ†ä¸ºä¸¤ç±»é”™é¢˜ï¼šçœ‹å­—é€‰æ‹¼éŸ³é”™è¯¯ å’Œ å¬éŸ³é€‰å­—é”™è¯¯
        let dictationMistakes = JSON.parse(localStorage.getItem('hanzi_dictation_mistakes') || '[]');
        let soundMistakes = JSON.parse(localStorage.getItem('hanzi_sound_mistakes') || '[]');
        // å‘åå…¼å®¹ï¼šå¦‚æœæœ‰æ—§çš„ mistakes æ•°æ®ï¼Œåˆå¹¶åˆ°ä¸¤ç±»ä¸­
        let oldMistakes = JSON.parse(localStorage.getItem('hanzi_mistakes') || '[]');
        let stats = JSON.parse(localStorage.getItem('hanzi_stats') || '{"totalLearned":0,"totalPractice":0,"correctCount":0}');

        // å…¼å®¹æ—§æ•°æ®ï¼šå°†æ—§ mistakes åˆå¹¶åˆ°ä¸¤ç±»
        function migrateOldMistakes() {
            if (oldMistakes.length > 0) {
                oldMistakes.forEach(m => {
                    const text = typeof m === 'object' ? m.text : m;
                    // é»˜è®¤å°†æ—§æ•°æ®éƒ½åŠ å…¥çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜
                    const existing = dictationMistakes.find(dm => typeof dm === 'object' ? dm.text === text : dm === text);
                    if (existing) {
                        if (typeof existing === 'object') {
                            existing.count++;
                            existing.lastWrong = new Date().toISOString();
                        }
                    } else {
                        dictationMistakes.push({ text: text, count: typeof m === 'object' ? m.count : 1, firstWrong: new Date().toISOString(), lastWrong: new Date().toISOString() });
                    }
                });
                // æ¸…ç©ºæ—§æ•°æ®å¹¶ä¿å­˜æ–°ç»“æ„
                localStorage.removeItem('hanzi_mistakes');
                saveDictationMistakes();
                saveSoundMistakes();
                oldMistakes = [];
            }
        }

        // è·å–æ‰€æœ‰é”™é¢˜ï¼ˆç”¨äºå‘åå…¼å®¹ï¼‰
        function getAllMistakes() {
            return [...dictationMistakes, ...soundMistakes];
        }

        // è·å–é”™é¢˜æ•°é‡
        function getMistakesCount() {
            return dictationMistakes.length + soundMistakes.length;
        }

        // å¬éŸ³é€‰å­—æ¸¸æˆçŠ¶æ€
        let gameQueue = [];
        let currentQuestion = null;
        let gameScore = 0;
        let gameTotal = 0;
        let soundAnswered = false;

        // ========== äº‘åŒæ­¥æ¨¡å— ==========

        // å¸¸é‡é…ç½®
        const SUPABASE_URL = 'https://febjcxekwzuzyzzvudsj.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZlYmpjeGVrd3p1enl6enZ1ZHNqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg2NzExNzYsImV4cCI6MjA4NDI0NzE3Nn0.igxKXfuiLWYJWJHOq5cYSjDMvtqBnQdmo20X0gyqMjc';
        const MAX_ENCRYPTED_DATA_SIZE = 10 * 1024 * 1024;  // 10MB
        const AUTO_SYNC_DELAY_MS = 3000;
        const PIN_LENGTH = 8;
        const EMAIL_DOMAIN = 'example.com';
        const ERROR_NO_DATA = 'PGRST116';
        const SESSION_EXPIRY_DAYS = 30;  // ä¼šè¯æœ‰æ•ˆæœŸ 30 å¤©
        const STORAGE_KEYS = {
            PIN: 'hanzi_pin',
            LAST_LOGIN: 'hanzi_last_login'
        };

        // çŠ¶æ€å˜é‡
        let currentUser = null;
        let currentPin = null;
        let supabaseClient = null;
        let syncTimeout = null;

        // DOM å…ƒç´ ç¼“å­˜
        let userInfoSection = null;
        let loginPrompt = null;
        let syncStatusDiv = null;
        let syncStatusText = null;
        let syncBtn = null;

        // ---------- Supabase å®¢æˆ·ç«¯åˆå§‹åŒ– ----------
        function initSupabase() {
            if (window.supabase) {
                supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase client initialized');
                return;
            }
            setTimeout(initSupabase, 100);
        }
        initSupabase();

        // ---------- æ•°æ®åŠ å¯†/è§£å¯† ----------
        function encryptData(data, pin) {
            const jsonString = JSON.stringify(data);
            return CryptoJS.AES.encrypt(jsonString, pin).toString();
        }

        function decryptData(encryptedData, pin) {
            try {
                const bytes = CryptoJS.AES.decrypt(encryptedData, pin);
                const decryptedString = bytes.toString(CryptoJS.enc.Utf8);
                if (!decryptedString) return null;
                return JSON.parse(decryptedString);
            } catch (e) {
                return null;
            }
        }

        // ---------- è®¤è¯å‡½æ•° ----------
        async function authenticateWithPin(pin) {
            if (!supabaseClient) {
                throw new Error('Supabase æœªé…ç½®');
            }

            const email = `pin${pin}@${EMAIL_DOMAIN}`;

            const { data: signInData, error: signInError } = await supabaseClient.auth.signInWithPassword({
                email: email,
                password: pin
            });

            if (!signInError) {
                return { user: signInData.user, session: signInData.session, isNew: false };
            }

            if (signInError.message === 'Invalid login credentials') {
                const { data: signUpData, error: signUpError } = await supabaseClient.auth.signUp({
                    email: email,
                    password: pin
                });

                if (signUpError) {
                    throw new Error(`æ³¨å†Œå¤±è´¥: ${signUpError.message}`);
                }

                return { user: signUpData.user, session: signUpData.session, isNew: true };
            }

            throw new Error(signInError.message);
        }

        // ---------- æ•°æ®å­˜å‚¨å‡½æ•° ----------
        async function saveUserData(userId, pin) {
            if (!supabaseClient) {
                throw new Error('Supabase æœªé…ç½®');
            }

            const data = {
                dictationMistakes: dictationMistakes,
                soundMistakes: soundMistakes,
                stats: stats,
                currentChars: currentChars,  // ä¹Ÿä¿å­˜å½“å‰å­¦ä¹ çš„å­—è¯
                version: 2,  // ç‰ˆæœ¬å‡çº§åˆ°2
                updatedAt: new Date().toISOString()
            };
            const encrypted = encryptData(data, pin);

            if (encrypted.length > MAX_ENCRYPTED_DATA_SIZE) {
                throw new Error('æ•°æ®å¤ªå¤§ï¼Œæ— æ³•åŒæ­¥');
            }

            const { error } = await supabaseClient
                .from('user_learning_data')
                .upsert({
                    user_id: userId,
                    encrypted_data: encrypted,
                    updated_at: new Date().toISOString()
                }, {
                    onConflict: 'user_id'
                });

            if (error) {
                throw new Error(`ä¿å­˜å¤±è´¥: ${error.message}`);
            }
        }

        async function loadUserData(userId) {
            if (!supabaseClient) {
                throw new Error('Supabase æœªé…ç½®');
            }

            const { data, error } = await supabaseClient
                .from('user_learning_data')
                .select('encrypted_data')
                .eq('user_id', userId)
                .single();

            if (error) {
                if (error.code === ERROR_NO_DATA) {
                    return null;
                }
                throw new Error(`åŠ è½½å¤±è´¥: ${error.message}`);
            }

            return data?.encrypted_data || null;
        }

        // ---------- UI æ§åˆ¶å‡½æ•° ----------
        function openLoginModal() {
            document.getElementById('loginModal').classList.add('active');
            document.getElementById('loginMessage').innerHTML = '';
            document.getElementById('pinInput').value = '';
            document.getElementById('pinInput').focus();
        }

        function closeLoginModal() {
            document.getElementById('loginModal').classList.remove('active');
        }

        function updateLoginUI() {
            if (!userInfoSection) {
                userInfoSection = document.getElementById('userInfoSection');
                loginPrompt = document.getElementById('loginPrompt');
            }

            if (currentUser) {
                userInfoSection.style.display = 'block';
                loginPrompt.style.display = 'none';
                updateSyncStatus('synced', 'å·²åŒæ­¥');
            } else {
                userInfoSection.style.display = 'none';
                loginPrompt.style.display = 'block';
            }
        }

        function updateSyncStatus(status, text) {
            if (!syncStatusDiv || !syncStatusText) {
                syncStatusDiv = document.getElementById('syncStatus');
                syncStatusText = document.getElementById('syncStatusText');
            }
            syncStatusDiv.className = 'sync-status ' + status;
            syncStatusText.textContent = text;
        }

        function showLoginMessage(html) {
            document.getElementById('loginMessage').innerHTML = html;
        }

        // ---------- ç™»å½•/ç™»å‡ºå¤„ç† ----------
        async function handleLogin() {
            const pin = document.getElementById('pinInput').value.trim();

            if (!isValidPin(pin)) {
                showLoginMessage('<div class="error-message">è¯·è¾“å…¥8ä½æ•°å­—PINç </div>');
                return;
            }

            showLoginMessage('<div class="success-message">æ­£åœ¨å¤„ç†...</div>');

            try {
                const authResult = await authenticateWithPin(pin);
                const userId = authResult.user.id;

                if (authResult.isNew) {
                    await handleNewUser(authResult, pin, userId);
                } else {
                    await handleExistingUser(authResult, pin, userId);
                }

                updateLoginUI();
                setTimeout(() => {
                    closeLoginModal();
                    updateStatsSection();
                    updateMistakesSection();
                }, 1000);

            } catch (error) {
                console.error('Login error:', error);
                showLoginMessage(`<div class="error-message">ç™»å½•å¤±è´¥: ${error.message}</div>`);
            }
        }

        function isValidPin(pin) {
            return new RegExp(`^\\d{${PIN_LENGTH}}$`).test(pin);
        }

        async function handleNewUser(authResult, pin, userId) {
            await saveUserData(userId, pin);
            currentUser = authResult;
            currentPin = pin;
            saveSession(pin);
            saveLocalData();
            console.log('New user logged in:', { userId, hasPin: !!currentPin });
            showLoginMessage('<div class="success-message">æ³¨å†ŒæˆåŠŸï¼å·²åˆ›å»ºäº‘ç«¯å¤‡ä»½</div>');
        }

        async function handleExistingUser(authResult, pin, userId) {
            const encryptedData = await loadUserData(userId);

            if (encryptedData) {
                const decryptedData = decryptData(encryptedData, pin);
                if (decryptedData) {
                    // å…¼å®¹ç‰ˆæœ¬1å’Œç‰ˆæœ¬2çš„æ•°æ®æ ¼å¼
                    if (decryptedData.version >= 2) {
                        dictationMistakes = decryptedData.dictationMistakes || [];
                        soundMistakes = decryptedData.soundMistakes || [];
                    } else {
                        // æ—§ç‰ˆæœ¬æ•°æ®ï¼Œè¿ç§»åˆ°æ–°ç»“æ„
                        const oldMistakesData = decryptedData.mistakes || [];
                        oldMistakesData.forEach(m => {
                            const text = typeof m === 'object' ? m.text : m;
                            dictationMistakes.push({ text: text, count: typeof m === 'object' ? m.count : 1, firstWrong: new Date().toISOString(), lastWrong: new Date().toISOString() });
                        });
                    }
                    stats = decryptedData.stats || { totalLearned: 0, totalPractice: 0, correctCount: 0 };
                    currentChars = decryptedData.currentChars || [];
                    saveDictationMistakes();
                    saveSoundMistakes();
                    console.log('Cloud data loaded:', { dictationMistakes: dictationMistakes.length, soundMistakes: soundMistakes.length, stats, currentCharsCount: currentChars.length });
                }
            }

            currentUser = authResult;
            currentPin = pin;
            saveSession(pin);
            saveLocalData();
            updateAddedWordsPreview();
            updateAllSections();
            console.log('Existing user logged in:', { userId, hasPin: !!currentPin });
            showLoginMessage('<div class="success-message">ç™»å½•æˆåŠŸï¼æ•°æ®å·²åŒæ­¥</div>');
        }

        async function handleLogout() {
            if (!confirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿæœ¬åœ°æ•°æ®å°†ä¿ç•™ï¼Œä½†ä¸ä¼šè‡ªåŠ¨åŒæ­¥åˆ°äº‘ç«¯ã€‚')) {
                return;
            }

            if (supabaseClient) {
                await supabaseClient.auth.signOut();
            }

            currentUser = null;
            currentPin = null;
            clearSession();
            updateLoginUI();
        }

        // ---------- ä¼šè¯æŒä¹…åŒ– ----------
        function saveSession(pin) {
            localStorage.setItem(STORAGE_KEYS.PIN, pin);
            localStorage.setItem(STORAGE_KEYS.LAST_LOGIN, Date.now().toString());
        }

        function clearSession() {
            localStorage.removeItem(STORAGE_KEYS.PIN);
            localStorage.removeItem(STORAGE_KEYS.LAST_LOGIN);
        }

        function isSessionValid() {
            const lastLogin = localStorage.getItem(STORAGE_KEYS.LAST_LOGIN);
            if (!lastLogin) return false;

            const daysSinceLogin = (Date.now() - parseInt(lastLogin)) / (1000 * 60 * 60 * 24);
            return daysSinceLogin <= SESSION_EXPIRY_DAYS;
        }

        function getSavedPin() {
            if (!isSessionValid()) {
                clearSession();
                return null;
            }
            return localStorage.getItem(STORAGE_KEYS.PIN);
        }

        // ---------- æ•°æ®åŒæ­¥å‡½æ•° ----------
        async function manualSync() {
            if (!currentUser || !currentPin) {
                alert('è¯·å…ˆç™»å½•');
                return;
            }

            if (!syncBtn) {
                syncBtn = document.getElementById('syncBtn');
            }

            syncBtn.disabled = true;
            updateSyncStatus('syncing', 'æ­£åœ¨åŒæ­¥...');

            try {
                await saveUserData(currentUser.user.id, currentPin);
                updateSyncStatus('synced', 'åŒæ­¥æˆåŠŸ: ' + new Date().toLocaleTimeString());
            } catch (error) {
                console.error('Sync error:', error);
                updateSyncStatus('error', 'åŒæ­¥å¤±è´¥: ' + error.message);
            } finally {
                syncBtn.disabled = false;
            }
        }

        function autoSync() {
            if (!currentUser || !currentPin) {
                console.log('Auto sync skipped: no user or pin', { hasUser: !!currentUser, hasPin: !!currentPin });
                return;
            }

            if (syncTimeout) {
                clearTimeout(syncTimeout);
            }

            console.log('Scheduling auto sync in', AUTO_SYNC_DELAY_MS, 'ms');

            syncTimeout = setTimeout(async () => {
                try {
                    console.log('Executing auto sync for user:', currentUser.user.id);
                    await saveUserData(currentUser.user.id, currentPin);
                    updateSyncStatus('synced', 'å·²è‡ªåŠ¨åŒæ­¥');
                    console.log('Auto sync completed successfully');
                } catch (error) {
                    console.error('Auto sync failed:', error);
                }
            }, AUTO_SYNC_DELAY_MS);
        }

        function saveLocalData() {
            localStorage.setItem('hanzi_mistakes', JSON.stringify(mistakes));
            localStorage.setItem('hanzi_stats', JSON.stringify(stats));
        }

        async function initCloudSync() {
            if (!supabaseClient || SUPABASE_URL === 'YOUR_SUPABASE_URL') {
                console.log('Supabase æœªé…ç½®ï¼Œäº‘ç«¯åŒæ­¥åŠŸèƒ½ä¸å¯ç”¨');
                updateLoginUI();
                return;
            }

            try {
                console.log('Checking for existing session...');
                // æ£€æŸ¥ Supabase Auth çš„ session
                const { data: { session } } = await supabaseClient.auth.getSession();

                if (session) {
                    console.log('Found Supabase session for user:', session.user.id);
                    const savedPin = getSavedPin();

                    if (savedPin) {
                        console.log('Found saved PIN, restoring session...');
                        // æœ‰æœ‰æ•ˆçš„ session å’Œ PINï¼Œæ¢å¤ç™»å½•çŠ¶æ€
                        currentUser = { user: session.user, session: session };
                        currentPin = savedPin;

                        // ä»äº‘ç«¯åŠ è½½æœ€æ–°æ•°æ®
                        const encryptedData = await loadUserData(session.user.id);
                        if (encryptedData) {
                            const decryptedData = decryptData(encryptedData, savedPin);
                            if (decryptedData) {
                                // å…¼å®¹ç‰ˆæœ¬1å’Œç‰ˆæœ¬2çš„æ•°æ®æ ¼å¼
                                if (decryptedData.version >= 2) {
                                    dictationMistakes = decryptedData.dictationMistakes || [];
                                    soundMistakes = decryptedData.soundMistakes || [];
                                } else {
                                    // æ—§ç‰ˆæœ¬æ•°æ®ï¼Œè¿ç§»åˆ°æ–°ç»“æ„
                                    const oldMistakesData = decryptedData.mistakes || [];
                                    oldMistakesData.forEach(m => {
                                        const text = typeof m === 'object' ? m.text : m;
                                        dictationMistakes.push({ text: text, count: typeof m === 'object' ? m.count : 1, firstWrong: new Date().toISOString(), lastWrong: new Date().toISOString() });
                                    });
                                }
                                stats = decryptedData.stats || { totalLearned: 0, totalPractice: 0, correctCount: 0 };
                                currentChars = decryptedData.currentChars || [];
                                saveDictationMistakes();
                                saveSoundMistakes();
                                console.log('Cloud data restored:', { dictationMistakes: dictationMistakes.length, soundMistakes: soundMistakes.length, stats, currentCharsCount: currentChars.length });
                            }
                        } else {
                            console.log('No cloud data found, using local data');
                        }

                        console.log('Session restored successfully:', { hasUser: !!currentUser, hasPin: !!currentPin });
                    } else {
                        console.log('No saved PIN found, signing out...');
                        // æœ‰ Supabase session ä½†æ²¡æœ‰ PINï¼ˆå¯èƒ½æ˜¯è¿‡æœŸäº†ï¼‰
                        await supabaseClient.auth.signOut();
                    }
                } else {
                    console.log('No Supabase session found');
                }
            } catch (error) {
                console.error('Session restore failed:', error);
            }

            updateLoginUI();
        }

        // ---------- æ•°æ®ä¿å­˜å‡½æ•°ï¼ˆå¸¦è‡ªåŠ¨åŒæ­¥ï¼‰ ----------
        function saveDictationMistakes() {
            localStorage.setItem('hanzi_dictation_mistakes', JSON.stringify(dictationMistakes));
            autoSync();
        }

        function saveSoundMistakes() {
            localStorage.setItem('hanzi_sound_mistakes', JSON.stringify(soundMistakes));
            autoSync();
        }

        function saveStatsToLocal() {
            stats.lastPractice = new Date().toISOString();
            localStorage.setItem('hanzi_stats', JSON.stringify(stats));
        }

        function saveStats() {
            saveStatsToLocal();
            autoSync();
        }

        // é¡µé¢åˆå§‹åŒ–
        window.addEventListener('load', initCloudSync);

        // ========== æ ¸å¿ƒå­¦ä¹ åŠŸèƒ½ ==========

        // åˆå§‹åŒ–æ ‡ç­¾é¡µåˆ‡æ¢
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.practice-section').forEach(s => s.classList.remove('active'));
                btn.classList.add('active');
                document.getElementById(btn.dataset.tab + '-section').classList.add('active');

                // åˆ‡æ¢åˆ°é”™å­—é›†æˆ–ç»Ÿè®¡æ—¶åˆ·æ–°
                if (btn.dataset.tab === 'mistakes') updateMistakesSection();
                if (btn.dataset.tab === 'stats') updateStatsSection();
            });
        });

        // è¾“å…¥æ¡†ä¸­æ–‡è¾“å…¥æ³•å¤„ç†
        let isComposing = false;
        let lastProcessedValue = '';
        const charInput = document.getElementById('charInput');

        charInput.addEventListener('compositionstart', () => {
            isComposing = true;
        });

        charInput.addEventListener('compositionend', () => {
            isComposing = false;
        });

        charInput.addEventListener('input', (e) => {
            const input = e.target;
            const currentValue = input.value;

            // é¿å…é‡å¤å¤„ç†ç›¸åŒçš„å€¼
            if (currentValue === lastProcessedValue) {
                return;
            }

            // æ­£åœ¨è¾“å…¥æ³•ä¸­ï¼Œä¸å¤„ç†
            if (isComposing) {
                lastProcessedValue = currentValue;
                return;
            }

            // è¿‡æ»¤éæ³•å­—ç¬¦
            const selectionStart = input.selectionStart;
            const originalValue = currentValue;
            const filteredValue = originalValue.replace(/[^\u4e00-\u9fa5,ï¼Œã€\s]/g, '');

            if (filteredValue !== originalValue) {
                input.value = filteredValue;
                const newCursorPos = Math.max(0, selectionStart - (originalValue.length - filteredValue.length));
                input.setSelectionRange(newCursorPos, newCursorPos);
                lastProcessedValue = filteredValue;
            } else {
                lastProcessedValue = currentValue;
            }
        });

        // ç›‘å¬å›è½¦é”® - è§¦å‘æ·»åŠ ï¼ˆåœ¨éè¾“å…¥æ³•çŠ¶æ€ä¸‹ï¼‰
        charInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !isComposing) {
                e.preventDefault();
                addInput();
            }
        });

        // æ·»åŠ è¾“å…¥çš„å†…å®¹
        function addInput() {
            const input = document.getElementById('charInput');
            const value = input.value.trim();

            if (!value) {
                return;
            }

            // ä½¿ç”¨æ›´ç®€å•çš„åˆ†éš”ç¬¦å¤„ç†ï¼šå…ˆæ›¿æ¢æ‰€æœ‰åˆ†éš”ç¬¦ä¸ºç©ºæ ¼ï¼Œç„¶åæŒ‰ç©ºæ ¼åˆ†å‰²
            const normalized = value
                .replace(/,/g, ' ')
                .replace(/ï¼Œ/g, ' ')
                .replace(/ã€/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();

            if (!normalized) {
                return;
            }

            const newChars = normalized.split(' ').filter(s => s.length > 0);
            if (newChars.length === 0) {
                return;
            }

            // åˆå¹¶å»é‡
            currentChars = [...new Set([...currentChars, ...newChars])];
            updateAllSections();
            updateAddedWordsPreview();

            // æ¸…ç©ºè¾“å…¥æ¡†å¹¶èšç„¦
            input.value = '';
            lastProcessedValue = '';  // é‡ç½®å¤„ç†çŠ¶æ€
            input.focus();
        }

        // æ¸…ç©ºè¾“å…¥æ¡†
        function clearInput() {
            const input = document.getElementById('charInput');
            input.value = '';
            lastProcessedValue = '';  // é‡ç½®å¤„ç†çŠ¶æ€
            input.focus();
        }

        // æ¸…ç©ºæ‰€æœ‰å·²æ·»åŠ çš„å†…å®¹
        function clearAll() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å·²æ·»åŠ çš„å­—è¯å—ï¼Ÿ')) {
                currentChars = [];
                updateAllSections();
                updateAddedWordsPreview();
            }
        }

        // æ›´æ–°å·²æ·»åŠ å­—è¯é¢„è§ˆ
        function updateAddedWordsPreview() {
            const preview = document.getElementById('addedWordsPreview');
            const list = document.getElementById('addedWordsList');

            if (currentChars.length > 0) {
                preview.style.display = 'block';
                list.textContent = currentChars.join('ã€');
            } else {
                preview.style.display = 'none';
            }
        }

        function updateAllSections() {
            updatePracticeSection();
            updateSoundSection();
        }

        // è½¬ä¹‰HTMLç‰¹æ®Šå­—ç¬¦
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // è½¬ä¹‰å­—ç¬¦ä¸²ç”¨äºJavaScript
        function escapeJs(text) {
            return text.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/"/g, '\\"');
        }

        function getPinyin(text) {
            try {
                return pinyinPro.pinyin(text, { toneType: 'symbol' });
            } catch (e) {
                return '?';
            }
        }

        // æ·»åŠ åˆ°å·²å­¦å­—è¯
        function addToLearned(texts) {
            texts.forEach(text => {
                if (!stats.learnedWords) stats.learnedWords = [];
                if (!stats.learnedWords.includes(text)) {
                    stats.learnedWords.push(text);
                    stats.totalLearned = stats.learnedWords.length;
                }
            });
            saveStats();
        }

        // æ·»åŠ åˆ°é”™é¢˜é›† (type: 'dictation' æˆ– 'sound')
        function addToMistakes(text, type = 'dictation') {
            const mistakeArray = type === 'sound' ? soundMistakes : dictationMistakes;
            const existing = mistakeArray.find(m => typeof m === 'object' ? m.text === text : m === text);
            if (existing) {
                if (typeof existing === 'object') {
                    existing.count++;
                    existing.lastWrong = new Date().toISOString();
                } else {
                    // è½¬æ¢æ—§æ•°æ®æ ¼å¼
                    const idx = mistakeArray.indexOf(existing);
                    mistakeArray[idx] = { text: existing, count: 2, firstWrong: new Date().toISOString(), lastWrong: new Date().toISOString() };
                }
            } else {
                mistakeArray.push({ text: text, count: 1, firstWrong: new Date().toISOString(), lastWrong: new Date().toISOString() });
            }
            if (type === 'sound') {
                saveSoundMistakes();
            } else {
                saveDictationMistakes();
            }
        }

        // ä»é”™é¢˜é›†ç§»é™¤
        function removeFromMistakes(text, type = 'dictation') {
            const mistakeArray = type === 'sound' ? soundMistakes : dictationMistakes;
            if (typeof text === 'number') {
                mistakeArray.splice(text, 1);
            } else {
                const idx = mistakeArray.findIndex(m => (typeof m === 'object' ? m.text : m) === text);
                if (idx !== -1) {
                    mistakeArray.splice(idx, 1);
                }
            }
            if (type === 'sound') {
                saveSoundMistakes();
            } else {
                saveDictationMistakes();
            }
            updateMistakesSection();
            updateStatsSection();
        }

        function clearMistakes() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰é”™é¢˜å—ï¼Ÿ')) {
                dictationMistakes = [];
                soundMistakes = [];
                saveDictationMistakes();
                saveSoundMistakes();
                updateMistakesSection();
                updateStatsSection();
            }
        }

        function clearStats() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ç»Ÿè®¡æ•°æ®å—ï¼Ÿ')) {
                stats = { totalLearned: 0, totalPractice: 0, correctCount: 0, learnedWords: [] };
                saveStats();
                updateStatsSection();
            }
        }

        // æ›´æ–°ç»ƒä¹ æœ¬ - çœ‹å­—é€‰æ‹¼éŸ³æ¨¡å¼
        function updatePracticeSection() {
            const container = document.getElementById('practice-content');

            // ä¼˜å…ˆä½¿ç”¨çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ï¼Œå…¶æ¬¡ä½¿ç”¨å½“å‰è¾“å…¥çš„å­—è¯
            const practiceWords = dictationMistakes.length > 0
                ? dictationMistakes.map(m => typeof m === 'object' ? m.text : m)
                : currentChars;

            if (practiceWords.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="emoji">ğŸ“</div>
                        <p>è¯·å…ˆè¾“å…¥å­—è¯ï¼Œæˆ–ç§¯ç´¯ä¸€äº›çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜åå¼€å§‹ç»ƒä¹ </p>
                    </div>
                `;
                return;
            }

            // æ˜¾ç¤ºçœ‹å­—é€‰æ‹¼éŸ³ç•Œé¢
            showPinyinQuizUI(container, practiceWords);
        }

        // çœ‹å­—é€‰æ‹¼éŸ³ç•Œé¢
        function showPinyinQuizUI(container, words) {
            // æ‰“ä¹±é¡ºåº
            const shuffledWords = [...words].sort(() => Math.random() - 0.5);
            window.pinyinQuizQueue = shuffledWords;
            window.pinyinQuizIndex = 0;
            window.pinyinQuizScore = 0;

            // å¦‚æœæœ‰çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ï¼Œæç¤ºç”¨æˆ·
            const isUsingMistakes = dictationMistakes.length > 0;
            const hintMessage = isUsingMistakes
                ? `<p style="text-align: center; color: #667eea; font-weight: bold; margin-bottom: 15px;">ğŸ¯ æ­£åœ¨ç»ƒä¹ çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ä¸­çš„ ${words.length} ä¸ªå­—</p>`
                : `<p style="text-align: center; color: #666; margin-bottom: 15px;">ğŸ“ æ­£åœ¨ç»ƒä¹  ${words.length} ä¸ªå­—è¯</p>`;

            container.innerHTML = `
                <div class="pinyin-quiz-container">
                    ${hintMessage}

                    <div class="dictation-progress" style="text-align: center; margin-bottom: 20px; padding: 15px; background: #f8f9ff; border-radius: 10px;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #667eea;">
                            è¿›åº¦: <span id="pinyinQuizProgress">1 / ${words.length}</span>
                        </div>
                        <div style="margin-top: 10px;">
                            <span style="color: #11998e;">âœ“ æ­£ç¡®: <span id="pinyinQuizCorrect">0</span></span>
                            <span style="margin-left: 20px; color: #eb3349;">âœ— é”™è¯¯: <span id="pinyinQuizWrong">0</span></span>
                        </div>
                    </div>

                    <div id="pinyinQuizGameArea" style="text-align: center; padding: 40px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%); border-radius: 20px;">
                        <div id="pinyinQuizChar" style="font-size: 10em; font-weight: bold; color: #667eea; margin-bottom: 30px; text-shadow: 2px 2px 4px rgba(0,0,0,0.1);">
                            å­—
                        </div>

                        <p style="color: #666; margin-bottom: 20px;">è¿™ä¸ªå­—çš„æ‹¼éŸ³æ˜¯ï¼Ÿ</p>

                        <div id="pinyinQuizOptions" class="pinyin-quiz-options" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-width: 400px; margin: 0 auto;">
                            <!-- é€‰é¡¹å°†åœ¨è¿™é‡Œç”Ÿæˆ -->
                        </div>

                        <button onclick="speakText(window.pinyinQuizQueue[window.pinyinQuizIndex])" style="margin-top: 30px; padding: 12px 25px; background: #f0f0f0; border: none; border-radius: 10px; cursor: pointer; font-size: 1em;">
                            ğŸ”Š å¬å‘éŸ³æç¤º
                        </button>
                    </div>
                </div>
            `;

            // å¼€å§‹ç¬¬ä¸€é¢˜
            nextPinyinQuizQuestion();
        }

        // ä¸‹ä¸€é¢˜
        function nextPinyinQuizQuestion() {
            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (window.pinyinQuizIndex >= window.pinyinQuizQueue.length) {
                showPinyinQuizResult();
                return;
            }

            const currentWord = window.pinyinQuizQueue[window.pinyinQuizIndex];
            const correctPinyin = getPinyin(currentWord);

            // æ›´æ–°è¿›åº¦
            document.getElementById('pinyinQuizProgress').textContent = `${window.pinyinQuizIndex + 1} / ${window.pinyinQuizQueue.length}`;

            // æ˜¾ç¤ºæ±‰å­—
            document.getElementById('pinyinQuizChar').textContent = currentWord;

            // ç”Ÿæˆæœ‰è¿·æƒ‘æ€§çš„é€‰é¡¹
            const options = generateConfusingOptions(correctPinyin);

            // æ‰“ä¹±é€‰é¡¹é¡ºåº
            options.sort(() => Math.random() - 0.5);

            // ç”Ÿæˆé€‰é¡¹æŒ‰é’®
            const optionsContainer = document.getElementById('pinyinQuizOptions');
            optionsContainer.innerHTML = options.map((pinyin, idx) => `
                <button class="pinyin-option-btn" onclick="checkPinyinQuizAnswer('${pinyin}', '${correctPinyin}', ${idx}, this)"
                    style="padding: 15px 25px; font-size: 1.5em; border: 3px solid #ddd; border-radius: 10px; background: white; cursor: pointer; transition: all 0.3s;">
                    ${pinyin}
                </button>
            `).join('');
        }

        // ç”Ÿæˆæœ‰è¿·æƒ‘æ€§çš„æ‹¼éŸ³é€‰é¡¹
        function generateConfusingOptions(correctPinyin) {
            const options = [correctPinyin];

            // æå–æ‹¼éŸ³çš„å„ä¸ªéƒ¨åˆ†
            const pinyinWithoutTone = correctPinyin.replace(/[ÄÃ¡ÇÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœ]/g, (match) => {
                const toneMap = {
                    'Ä': 'a', 'Ã¡': 'a', 'Ç': 'a', 'Ã ': 'a',
                    'Ä“': 'e', 'Ã©': 'e', 'Ä›': 'e', 'Ã¨': 'e',
                    'Ä«': 'i', 'Ã­': 'i', 'Ç': 'i', 'Ã¬': 'i',
                    'Å': 'o', 'Ã³': 'o', 'Ç’': 'o', 'Ã²': 'o',
                    'Å«': 'u', 'Ãº': 'u', 'Ç”': 'u', 'Ã¹': 'u',
                    'Ç–': 'v', 'Ç˜': 'v', 'Çš': 'v', 'Çœ': 'v'
                };
                return toneMap[match] || match;
            });

            // è·å–å£°æ¯å’ŒéŸµæ¯
            let initial = '';
            let final = pinyinWithoutTone;
            for (let i = 0; i < pinyinWithoutTone.length; i++) {
                if ('aeiouv'.includes(pinyinWithoutTone[i])) {
                    initial = pinyinWithoutTone.substring(0, i);
                    final = pinyinWithoutTone.substring(i);
                    break;
                }
            }

            // ç”Ÿæˆä¸åŒå£°è°ƒçš„é€‰é¡¹
            const tones = ['Ä', 'Ã¡', 'Ç', 'Ã ', 'Ä“', 'Ã©', 'Ä›', 'Ã¨', 'Ä«', 'Ã­', 'Ç', 'Ã¬',
                           'Å', 'Ã³', 'Ç’', 'Ã²', 'Å«', 'Ãº', 'Ç”', 'Ã¹', 'Ç–', 'Ç˜', 'Çš', 'Çœ',
                           'a', 'e', 'i', 'o', 'u', 'v'];
            const toneNum = ['Ä', 'Ã¡', 'Ç', 'Ã '].includes(correctPinyin[correctPinyin.length - 1]) ? correctPinyin[correctPinyin.length - 1] : '';

            // å°è¯•ç”Ÿæˆä¸åŒå£°è°ƒ
            for (let tone of ['Ä', 'Ã¡', 'Ç', 'Ã ']) {
                if (tone !== toneNum) {
                    const similarPinyin = pinyinWithoutTone.slice(0, -1) + tone;
                    if (similarPinyin !== correctPinyin && !options.includes(similarPinyin)) {
                        options.push(similarPinyin);
                        if (options.length >= 4) break;
                    }
                }
            }

            // å¦‚æœè¿˜ä¸å¤Ÿï¼Œæ·»åŠ ç›¸ä¼¼å£°æ¯çš„é€‰é¡¹
            if (options.length < 4) {
                const similarInitials = {
                    'b': ['p', 'm'], 'p': ['b', 'm'], 'm': ['b', 'p'],
                    'd': ['t', 'n'], 't': ['d', 'n'], 'n': ['d', 't', 'l'], 'l': ['n', 't'],
                    'g': ['k', 'h'], 'k': ['g', 'h'], 'h': ['g', 'k'],
                    'j': ['q', 'x'], 'q': ['j', 'x'], 'x': ['j', 'q'],
                    'zh': ['ch', 'sh'], 'ch': ['zh', 'sh'], 'sh': ['zh', 'ch'],
                    'z': ['c', 's'], 'c': ['z', 's'], 's': ['z', 'c'],
                    'r': ['l', 'n'],
                    'f': ['h'], 'w': [''], 'y': ['']
                };

                if (initial && similarInitials[initial]) {
                    for (let simInitial of similarInitials[initial]) {
                        const similarPinyin = simInitial + final;
                        if (similarPinyin !== correctPinyin && similarPinyin.length > 1 && !options.includes(similarPinyin)) {
                            options.push(similarPinyin);
                            if (options.length >= 4) break;
                        }
                    }
                }
            }

            // å¦‚æœè¿˜ä¸å¤Ÿï¼Œä½¿ç”¨ç›¸ä¼¼éŸµæ¯
            if (options.length < 4) {
                const similarFinals = {
                    'a': ['e', 'o', 'u'],
                    'e': ['a', 'o', 'u'],
                    'i': ['u', 'v'],
                    'o': ['a', 'e', 'u'],
                    'u': ['a', 'o', 'i'],
                    'v': ['i', 'u'],
                    'ai': ['ei', 'ao'],
                    'ei': ['ai', 'ui'],
                    'ao': ['ou', 'ai'],
                    'ou': ['iu', 'ao'],
                    'an': ['en', 'ang'],
                    'en': ['an', 'eng'],
                    'ang': ['an', 'eng'],
                    'eng': ['en', 'ang'],
                    'ia': ['ua', 'ie'],
                    'ie': ['ue', 'ia'],
                    'ua': ['ia', 'uo'],
                    'uo': ['ou', 'ua'],
                    'iu': ['ou', 'ui'],
                    'ui': ['ei', 'iu']
                };

                if (final && similarFinals[final]) {
                    for (let simFinal of similarFinals[final]) {
                        const similarPinyin = initial + simFinal;
                        if (similarPinyin !== correctPinyin && similarPinyin.length > 1 && !options.includes(similarPinyin)) {
                            options.push(similarPinyin);
                            if (options.length >= 4) break;
                        }
                    }
                }
            }

            // å¦‚æœä»ç„¶ä¸å¤Ÿ4ä¸ªï¼Œç”¨éšæœºæ‹¼éŸ³è¡¥å……
            while (options.length < 4) {
                const allPinyins = ['bÄ', 'bÃ¡', 'bÇ', 'bÃ ', 'pÄ', 'pÃ¡', 'pÇ', 'pÃ ', 'mÄ', 'mÃ¡', 'mÇ', 'mÃ ',
                    'fÄ', 'fÃ¡', 'fÇ', 'fÃ ', 'dÄ', 'dÃ¡', 'dÇ', 'dÃ ', 'tÄ', 'tÃ¡', 'tÇ', 'tÃ ',
                    'nÄ', 'nÃ¡', 'nÇ', 'nÃ ', 'lÄ', 'lÃ¡', 'lÇ', 'lÃ ', 'gÄ', 'gÃ¡', 'gÇ', 'gÃ ',
                    'kÄ', 'kÃ¡', 'kÇ', 'kÃ ', 'hÄ', 'hÃ¡', 'hÇ', 'hÃ ', 'jÄ«', 'jÃ­', 'jÇ', 'jÃ¬',
                    'qÄ«', 'qÃ­', 'qÇ', 'qÃ¬', 'xÄ«', 'xÃ­', 'xÇ', 'xÃ¬', 'zhÄ«', 'zhÃ­', 'zhÇ', 'zhÃ¬',
                    'chÄ«', 'chÃ­', 'chÇ', 'chÃ¬', 'shÄ«', 'shÃ­', 'shÇ', 'shÃ¬', 'rÄ«', 'rÃ­', 'rÇ', 'rÃ¬',
                    'zÄ', 'zÃ¡', 'zÇ', 'zÃ ', 'cÄ', 'cÃ¡', 'cÇ', 'cÃ ', 'sÄ', 'sÃ¡', 'sÇ', 'sÃ ',
                    'yÄ', 'yÃ¡', 'yÇ', 'yÃ ', 'wÄ', 'wÃ¡', 'wÇ', 'wÃ '];
                const randomPinyin = allPinyins[Math.floor(Math.random() * allPinyins.length)];
                if (!options.includes(randomPinyin) && randomPinyin !== correctPinyin) {
                    options.push(randomPinyin);
                }
            }

            return options;
        }

        // æ£€æŸ¥æ‹¼éŸ³ç­”æ¡ˆ
        function checkPinyinQuizAnswer(selectedPinyin, correctPinyin, idx, button) {
            // ç¦ç”¨æ‰€æœ‰æŒ‰é’®
            const allButtons = document.querySelectorAll('.pinyin-option-btn');
            allButtons.forEach(btn => btn.disabled = true);

            const currentWord = window.pinyinQuizQueue[window.pinyinQuizIndex];

            if (selectedPinyin === correctPinyin) {
                // ç­”å¯¹äº†
                button.style.background = 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)';
                button.style.color = 'white';
                button.style.borderColor = '#11998e';
                window.pinyinQuizScore++;
                document.getElementById('pinyinQuizCorrect').textContent = window.pinyinQuizScore;

                stats.totalPractice++;
                stats.correctCount++;

                // å¦‚æœè¿™ä¸ªå­—åœ¨çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ä¸­ï¼Œç­”å¯¹æœ‰æ¦‚ç‡ç§»é™¤
                if (dictationMistakes.find(m => (typeof m === 'object' ? m.text : m) === currentWord)) {
                    if (Math.random() > 0.5) {
                        removeFromMistakes(currentWord, 'dictation');
                    }
                }
            } else {
                // ç­”é”™äº†
                button.style.background = 'linear-gradient(135deg, #eb3349 0%, #f45c43 100%)';
                button.style.color = 'white';
                button.style.borderColor = '#eb3349';

                // é«˜äº®æ­£ç¡®ç­”æ¡ˆ
                allButtons.forEach(btn => {
                    if (btn.textContent.trim() === correctPinyin) {
                        btn.style.background = 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)';
                        btn.style.color = 'white';
                    }
                });

                stats.totalPractice++;
                addToMistakes(currentWord, 'dictation');

                const wrongCount = window.pinyinQuizIndex - window.pinyinQuizScore + 1;
                document.getElementById('pinyinQuizWrong').textContent = wrongCount;
            }

            saveStats();

            // 1.5ç§’åä¸‹ä¸€é¢˜
            setTimeout(() => {
                window.pinyinQuizIndex++;
                nextPinyinQuizQuestion();
            }, 1500);
        }

        // æ˜¾ç¤ºæ‹¼éŸ³æµ‹éªŒç»“æœ
        function showPinyinQuizResult() {
            const container = document.getElementById('practice-content');
            const total = window.pinyinQuizQueue.length;
            const correct = window.pinyinQuizScore;
            const wrong = total - correct;
            const rate = Math.round((correct / total) * 100);

            container.innerHTML = `
                <div class="result-box" style="text-align: center; padding: 40px;">
                    <h2 style="color: #667eea; margin-bottom: 30px;">ğŸ‰ ç»ƒä¹ å®Œæˆï¼</h2>

                    <div class="score" style="font-size: 4em; color: ${rate >= 80 ? '#11998e' : rate >= 60 ? '#f39c12' : '#eb3349'};">
                        ${rate}%
                    </div>

                    <div class="message" style="font-size: 1.3em; color: #666; margin: 20px 0;">
                        ç­”å¯¹ ${correct} é¢˜ï¼Œç­”é”™ ${wrong} é¢˜
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 30px;">
                        <button class="btn btn-primary" onclick="updatePracticeSection()" style="padding: 15px 35px; font-size: 1.2em;">
                            ğŸ”„ å†æ¥ä¸€å±€
                        </button>
                        <button class="btn btn-secondary" onclick="showPinyinQuizUI(document.getElementById('practice-content'), window.pinyinQuizQueue)" style="padding: 15px 35px; font-size: 1.2em; background: #f0f0f0; color: #666;">
                            â†º é‡ç»ƒæœ¬ç»„
                        </button>
                    </div>
                </div>
            `;
        }

        // çœ‹å­—é€‰æ‹¼éŸ³ç•Œé¢ï¼ˆå¬å†™æ¨¡å¼çš„å†…éƒ¨å‡½æ•°ï¼‰
        function showDictationUI(container, words) {
            // æ‰“ä¹±é¡ºåº
            const shuffledWords = [...words].sort(() => Math.random() - 0.5);
            window.dictationQueue = shuffledWords;
            window.dictationIndex = 0;
            window.dictationScore = 0;

            // å¦‚æœæœ‰çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ï¼Œæç¤ºç”¨æˆ·
            const isUsingMistakes = dictationMistakes.length > 0;
            const hintMessage = isUsingMistakes
                ? `<p style="text-align: center; color: #667eea; font-weight: bold; margin-bottom: 15px;">ğŸ¯ æ­£åœ¨ç»ƒä¹ çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ä¸­çš„ ${words.length} ä¸ªå­—</p>`
                : `<p style="text-align: center; color: #666; margin-bottom: 15px;">ğŸ“ æ­£åœ¨ç»ƒä¹  ${words.length} ä¸ªå­—è¯</p>`;

            container.innerHTML = `
                <div class="dictation-container">
                    ${hintMessage}

                    <div class="dictation-progress" style="text-align: center; margin-bottom: 20px; padding: 15px; background: #f8f9ff; border-radius: 10px;">
                        <div style="font-size: 1.2em; font-weight: bold; color: #667eea;">
                            è¿›åº¦: <span id="dictationProgress">1 / ${words.length}</span>
                        </div>
                        <div style="margin-top: 10px;">
                            <span style="color: #11998e;">âœ“ æ­£ç¡®: <span id="dictationCorrect">0</span></span>
                            <span style="margin-left: 20px; color: #eb3349;">âœ— é”™è¯¯: <span id="dictationWrong">0</span></span>
                        </div>
                    </div>

                    <div id="dictationGameArea" style="text-align: center; padding: 30px; background: linear-gradient(135deg, #f8f9ff 0%, #e8f0ff 100%); border-radius: 20px;">
                        <button id="dictationSoundBtn" onclick="playCurrentWord()" class="sound-btn" style="width: 120px; height: 120px; font-size: 3em; margin-bottom: 20px;">
                            ğŸ”Š
                        </button>
                        <p style="color: #666; margin-bottom: 20px;">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®å¬å‘éŸ³ï¼Œç„¶ååœ¨ä¸‹æ–¹è¾“å…¥å¯¹åº”çš„æ±‰å­—</p>

                        <input type="text" id="dictationInput" placeholder="è¾“å…¥å¬åˆ°çš„æ±‰å­—"
                            style="font-size: 2em; padding: 15px; width: 200px; text-align: center; border: 3px solid #ddd; border-radius: 10px;"
                            onkeydown="if(event.key === 'Enter') checkDictationAnswer()">

                        <div style="margin-top: 20px;">
                            <button class="btn btn-primary" onclick="checkDictationAnswer()" style="padding: 12px 30px; font-size: 1.1em;">
                                âœ“ æäº¤ç­”æ¡ˆ
                            </button>
                            <button class="btn btn-secondary" onclick="skipDictationWord()" style="padding: 12px 30px; font-size: 1.1em; background: #f0f0f0; color: #666; margin-left: 10px;">
                                â­ è·³è¿‡
                            </button>
                        </div>

                        <div id="dictationResult" style="margin-top: 20px; font-size: 1.2em; font-weight: bold; min-height: 30px;"></div>
                    </div>
                </div>
            `;

            // è‡ªåŠ¨æ’­æ”¾ç¬¬ä¸€ä¸ªå­—
            setTimeout(() => playCurrentWord(), 300);
        }

        // æ’­æ”¾å½“å‰å­—
        function playCurrentWord() {
            if (window.dictationQueue && window.dictationIndex < window.dictationQueue.length) {
                const word = window.dictationQueue[window.dictationIndex];
                speakText(word);
            }
        }

        // æ£€æŸ¥çœ‹å­—é€‰æ‹¼éŸ³ç­”æ¡ˆ
        function checkDictationAnswer() {
            const input = document.getElementById('dictationInput');
            const resultDiv = document.getElementById('dictationResult');
            const userAnswer = input.value.trim();
            const correctAnswer = window.dictationQueue[window.dictationIndex];

            if (!userAnswer) {
                resultDiv.innerHTML = '<span style="color: #999;">è¯·è¾“å…¥ç­”æ¡ˆ</span>';
                return;
            }

            if (userAnswer === correctAnswer) {
                // ç­”å¯¹äº†
                resultDiv.innerHTML = '<span style="color: #11998e;">âœ“ æ­£ç¡®ï¼</span>';
                input.style.borderColor = '#11998e';
                input.style.background = '#f0fff9';
                window.dictationScore++;
                document.getElementById('dictationCorrect').textContent = window.dictationScore;

                stats.totalPractice++;
                stats.correctCount++;

                // å¦‚æœè¿™ä¸ªå­—åœ¨çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ä¸­ï¼Œç­”å¯¹ä¸€æ¬¡
                if (dictationMistakes.find(m => (typeof m === 'object' ? m.text : m) === correctAnswer)) {
                    // ç­”å¯¹3æ¬¡åä»çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜é›†ç§»é™¤ï¼ˆç®€åŒ–å¤„ç†ï¼šæ¯æ¬¡ç­”å¯¹æœ‰50%æ¦‚ç‡ç§»é™¤ï¼‰
                    if (Math.random() > 0.5) {
                        removeFromMistakes(correctAnswer, 'dictation');
                    }
                }
            } else {
                // ç­”é”™äº†
                resultDiv.innerHTML = `<span style="color: #eb3349;">âœ— é”™è¯¯ï¼æ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š${correctAnswer}</span>`;
                input.style.borderColor = '#eb3349';
                input.style.background = '#fff0f0';

                stats.totalPractice++;
                addToMistakes(correctAnswer, 'dictation');

                const wrongCount = window.dictationIndex - window.dictationScore + 1;
                document.getElementById('dictationWrong').textContent = wrongCount;
            }

            saveStats();

            // 1.5ç§’åä¸‹ä¸€é¢˜
            setTimeout(() => nextDictationWord(), 1500);
        }

        // è·³è¿‡å½“å‰å­—
        function skipDictationWord() {
            const correctAnswer = window.dictationQueue[window.dictationIndex];
            addToMistakes(correctAnswer, 'dictation'); // è·³è¿‡ä¹Ÿè®°ä¸ºçœ‹å­—é€‰æ‹¼éŸ³é”™è¯¯

            const resultDiv = document.getElementById('dictationResult');
            resultDiv.innerHTML = `<span style="color: #999;">å·²è·³è¿‡ï¼Œæ­£ç¡®ç­”æ¡ˆæ˜¯ï¼š${correctAnswer}</span>`;

            const wrongCount = window.dictationIndex - window.dictationScore + 1;
            document.getElementById('dictationWrong').textContent = wrongCount;

            setTimeout(() => nextDictationWord(), 1000);
        }

        // ä¸‹ä¸€ä¸ªå­—
        function nextDictationWord() {
            window.dictationIndex++;

            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (window.dictationIndex >= window.dictationQueue.length) {
                showDictationResult();
                return;
            }

            // æ›´æ–°è¿›åº¦
            document.getElementById('dictationProgress').textContent = `${window.dictationIndex + 1} / ${window.dictationQueue.length}`;

            // æ¸…ç©ºè¾“å…¥æ¡†
            const input = document.getElementById('dictationInput');
            input.value = '';
            input.style.borderColor = '#ddd';
            input.style.background = 'white';
            document.getElementById('dictationResult').textContent = '';

            // æ’­æ”¾ä¸‹ä¸€ä¸ªå­—
            setTimeout(() => playCurrentWord(), 500);
        }

        // æ˜¾ç¤ºçœ‹å­—é€‰æ‹¼éŸ³ç»“æœ
        function showDictationResult() {
            const container = document.getElementById('practice-content');
            const total = window.dictationQueue.length;
            const correct = window.dictationScore;
            const wrong = total - correct;
            const rate = Math.round((correct / total) * 100);

            container.innerHTML = `
                <div class="result-box" style="text-align: center; padding: 40px;">
                    <h2 style="color: #667eea; margin-bottom: 30px;">ğŸ‰ çœ‹å­—é€‰æ‹¼éŸ³ç»ƒä¹ å®Œæˆï¼</h2>

                    <div class="score" style="font-size: 4em; color: ${rate >= 80 ? '#11998e' : rate >= 60 ? '#f39c12' : '#eb3349'};">
                        ${rate}%
                    </div>

                    <div class="message" style="font-size: 1.3em; color: #666; margin: 20px 0;">
                        ç­”å¯¹ ${correct} é¢˜ï¼Œç­”é”™ ${wrong} é¢˜
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 30px;">
                        <button class="btn btn-primary" onclick="updatePracticeSection()" style="padding: 15px 35px; font-size: 1.2em;">
                            ğŸ”„ å†æ¥ä¸€å±€
                        </button>
                        <button class="btn btn-secondary" onclick="showDictationUI(document.getElementById('practice-content'), window.dictationQueue)" style="padding: 15px 35px; font-size: 1.2em; background: #f0f0f0; color: #666;">
                            â†º é‡ç»ƒæœ¬ç»„
                        </button>
                    </div>
                </div>
            `;
        }

        // æ£€æŸ¥æ‹¼éŸ³
        function checkPinyin(input, correctPinyin, text) {
            const cleanInput = input.value.toLowerCase()
                .replace(/[ÄÃ¡ÇÃ ]/g, 'a').replace(/[Ä“Ã©Ä›Ã¨]/g, 'e')
                .replace(/[Ä«Ã­ÇÃ¬]/g, 'i').replace(/[ÅÃ³Ç’Ã²]/g, 'o')
                .replace(/[Å«ÃºÇ”Ã¹]/g, 'u').replace(/[Ç–Ç˜ÇšÇœÃ¼]/g, 'v')
                .replace(/\d/g, '').replace(/\s/g, '');

            const cleanCorrect = correctPinyin.toLowerCase()
                .replace(/[ÄÃ¡ÇÃ ]/g, 'a').replace(/[Ä“Ã©Ä›Ã¨]/g, 'e')
                .replace(/[Ä«Ã­ÇÃ¬]/g, 'i').replace(/[ÅÃ³Ç’Ã²]/g, 'o')
                .replace(/[Å«ÃºÇ”Ã¹]/g, 'u').replace(/[Ç–Ç˜ÇšÇœÃ¼]/g, 'v')
                .replace(/\d/g, '').replace(/\s/g, '');

            stats.totalPractice++;

            if (cleanInput === cleanCorrect && cleanInput.length > 0) {
                input.classList.remove('wrong');
                input.classList.add('correct');
                stats.correctCount++;
                // å¦‚æœä¹‹å‰åœ¨é”™å­—é›†ï¼Œç­”å¯¹3æ¬¡åç§»é™¤
                const mistakeIndex = mistakes.indexOf(text);
                if (mistakeIndex !== -1) {
                    const count = parseInt(input.dataset.correctCount || 0) + 1;
                    input.dataset.correctCount = count;
                    if (count >= 3) {
                        removeFromMistakes(text);
                        input.dataset.correctCount = 0;
                    }
                }
            } else if (input.value.length > 0) {
                input.classList.remove('correct');
                input.classList.add('wrong');
                addToMistakes(text);
            } else {
                input.classList.remove('correct', 'wrong');
                stats.totalPractice--;
            }

            saveStats();
        }

        // æ›´æ–°å¬éŸ³é€‰å­—
        function updateSoundSection() {
            const container = document.getElementById('sound-content');

            // å¦‚æœæœ‰å¬éŸ³é”™é¢˜é›†ï¼Œæ˜¾ç¤ºé€‰æ‹©ç•Œé¢
            if (soundMistakes.length > 0) {
                showWordSelection(container);
                return;
            }

            // æ²¡æœ‰å¬éŸ³é”™é¢˜é›†ï¼Œä½¿ç”¨å½“å‰è¾“å…¥çš„å­—è¯
            if (currentChars.length < 2) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="emoji">ğŸ®</div>
                        <p>è¯·è‡³å°‘è¾“å…¥2ä¸ªå­—æˆ–è¯ç»„ï¼Œæˆ–ç§¯ç´¯ä¸€äº›å¬éŸ³é”™é¢˜åä½¿ç”¨å¬éŸ³é€‰å­—ç»ƒä¹ </p>
                    </div>
                `;
                return;
            }

            // ç›´æ¥ä½¿ç”¨å½“å‰å­—è¯å¼€å§‹æ¸¸æˆ
            startGameWithWords(currentChars);
        }

        // æ˜¾ç¤ºå­—è¯é€‰æ‹©ç•Œé¢
        function showWordSelection(container) {
            const mistakeWords = soundMistakes.map(m => typeof m === 'object' ? m.text : m);

            let html = `
                <div class="word-selection">
                    <h3 style="text-align: center; color: #667eea; margin-bottom: 15px;">ğŸ¯ é€‰æ‹©è¦ç»ƒä¹ çš„å­—è¯</h3>
                    <p style="text-align: center; color: #666; margin-bottom: 20px;">å¬éŸ³é”™é¢˜é›†å…±æœ‰ ${mistakeWords.length} ä¸ªå­—/è¯</p>

                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px; background: #f0f8ff; border-radius: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; flex: 1;">
                            <input type="checkbox" id="selectAllWords" onchange="toggleAllWords(this.checked)" style="width: 20px; height: 20px; cursor: pointer;">
                            <span style="font-weight: bold; color: #667eea;">å…¨é€‰ (${mistakeWords.length} ä¸ª)</span>
                        </label>
                        <span id="selectedCount" style="color: #666;">å·²é€‰: 0</span>
                    </div>

                    <div class="words-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 10px; margin-bottom: 20px; max-height: 300px; overflow-y: auto; padding: 10px; background: #f9f9f9; border-radius: 10px;">
            `;

            mistakeWords.forEach((word, idx) => {
                html += `
                    <label class="word-checkbox" style="display: flex; align-items: center; gap: 8px; padding: 10px; background: white; border-radius: 8px; cursor: pointer; transition: all 0.2s; border: 2px solid #e0e0e0;">
                        <input type="checkbox" class="word-checkbox-input" value="${escapeHtml(word)}" onchange="updateSelectedCount()" style="width: 18px; height: 18px; cursor: pointer;">
                        <span style="font-size: 1.2em; font-weight: bold;">${escapeHtml(word)}</span>
                    </label>
                `;
            });

            html += `
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button class="btn btn-primary" onclick="startSelectedPractice()" style="padding: 12px 30px; font-size: 1.1em;">
                            ğŸ® å¼€å§‹ç»ƒä¹ 
                        </button>
                        <button class="btn btn-secondary" onclick="practiceCurrentWords()" style="padding: 12px 30px; font-size: 1.1em; background: #f0f0f0; color: #666;">
                            ğŸ“ ç»ƒä¹ å½“å‰å­—è¯
                        </button>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // å…¨é€‰/å–æ¶ˆå…¨é€‰
        function toggleAllWords(checked) {
            const checkboxes = document.querySelectorAll('.word-checkbox-input');
            checkboxes.forEach(cb => cb.checked = checked);
            updateSelectedCount();
        }

        // æ›´æ–°å·²é€‰æ•°é‡
        function updateSelectedCount() {
            const checkboxes = document.querySelectorAll('.word-checkbox-input:checked');
            const count = checkboxes.length;
            document.getElementById('selectedCount').textContent = `å·²é€‰: ${count}`;

            // æ›´æ–°å…¨é€‰å¤é€‰æ¡†çŠ¶æ€
            const allCheckboxes = document.querySelectorAll('.word-checkbox-input');
            const selectAll = document.getElementById('selectAllWords');
            if (selectAll) {
                selectAll.checked = allCheckboxes.length > 0 && count === allCheckboxes.length;
                selectAll.indeterminate = count > 0 && count < allCheckboxes.length;
            }
        }

        // å¼€å§‹ç»ƒä¹ é€‰ä¸­çš„å­—è¯
        function startSelectedPractice() {
            const checkboxes = document.querySelectorAll('.word-checkbox-input:checked');
            const selectedWords = Array.from(checkboxes).map(cb => cb.value);

            if (selectedWords.length < 2) {
                alert('è¯·è‡³å°‘é€‰æ‹© 2 ä¸ªå­—è¯è¿›è¡Œç»ƒä¹ ');
                return;
            }

            startGameWithWords(selectedWords);
        }

        // ç»ƒä¹ å½“å‰è¾“å…¥çš„å­—è¯
        function practiceCurrentWords() {
            if (currentChars.length < 2) {
                alert('è¯·å…ˆè¾“å…¥è‡³å°‘ 2 ä¸ªå­—è¯');
                return;
            }
            startGameWithWords(currentChars);
        }

        // ä½¿ç”¨æŒ‡å®šå­—è¯å¼€å§‹æ¸¸æˆ
        function startGameWithWords(words) {
            // åˆ›å»ºæ¸¸æˆé˜Ÿåˆ—ï¼Œæ¯ä¸ªå­—/è¯ç»„éƒ½ä¼šè¢«é—®åˆ°
            gameQueue = [...words].sort(() => Math.random() - 0.5);
            gameScore = 0;
            gameTotal = gameQueue.length;

            startGame();
        }

        function startGame() {
            const container = document.getElementById('sound-content');

            if (gameQueue.length === 0) {
                // æ¸¸æˆç»“æŸ
                const rate = gameTotal > 0 ? Math.round((gameScore / gameTotal) * 100) : 0;
                container.innerHTML = `
                    <div class="result-box">
                        <div class="score">${rate}%</div>
                        <div class="message">ç­”å¯¹ ${gameScore} / ${gameTotal} é¢˜</div>
                        <button class="btn btn-primary" onclick="updateSoundSection()">ğŸ”„ å†æ¥ä¸€å±€</button>
                        ${soundMistakes.length > 0 ? '<button class="btn btn-primary" onclick="practiceMistakes()">ğŸ“ ç»ƒä¹ é”™é¢˜</button>' : ''}
                    </div>
                `;
                return;
            }

            currentQuestion = gameQueue.pop();
            const allOptions = [...currentChars.length >= 2 ? currentChars : soundMistakes.map(m => typeof m === 'object' ? m.text : m)];

            // ç”Ÿæˆé€‰é¡¹
            let options = [currentQuestion];
            while (options.length < 4 && options.length < allOptions.length) {
                const randomOption = allOptions[Math.floor(Math.random() * allOptions.length)];
                if (!options.includes(randomOption)) {
                    options.push(randomOption);
                }
            }
            options = options.sort(() => Math.random() - 0.5);

            const progress = ((gameTotal - gameQueue.length) / gameTotal * 100).toFixed(0);

            container.innerHTML = `
                <div class="game-progress">
                    <span>è¿›åº¦: ${gameTotal - gameQueue.length} / ${gameTotal}</span>
                    <span>å¾—åˆ†: ${gameScore}</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: ${progress}%"></div>
                </div>
                <div class="sound-game">
                    <button class="sound-btn" id="soundBtn" onclick="playSound()">ğŸ”Š</button>
                    <div class="options-grid" id="soundOptions">
                        ${options.map((opt, idx) => `<button class="option-btn" data-idx="${idx}" onclick="handleOptionClick(${idx})">${escapeHtml(opt)}</button>`).join('')}
                    </div>
                </div>
            `;

            // ä¿å­˜é€‰é¡¹åˆ°æ•°ç»„
            window.currentOptions = options;
            soundAnswered = false;
            // è‡ªåŠ¨æ’­æ”¾
            setTimeout(() => playSound(), 300);
        }

        function handleOptionClick(idx) {
            if (window.currentOptions && window.currentOptions[idx] !== undefined) {
                const btn = document.querySelector(`.option-btn[data-idx="${idx}"]`);
                checkAnswer(window.currentOptions[idx], btn);
            }
        }

        function playSound() {
            if (currentQuestion) {
                speakText(currentQuestion);
            }
        }

        function checkAnswer(answer, btn) {
            if (soundAnswered) return;
            soundAnswered = true;

            const allBtns = document.querySelectorAll('.option-btn');
            allBtns.forEach(b => b.disabled = true);
            document.getElementById('soundBtn').disabled = true;

            stats.totalPractice++;

            if (answer === currentQuestion) {
                btn.classList.add('correct');
                gameScore++;
                stats.correctCount++;
                speakText('ç­”å¯¹äº†ï¼');
            } else {
                btn.classList.add('wrong');
                allBtns.forEach(b => {
                    if (b.textContent === currentQuestion) {
                        b.classList.add('correct');
                    }
                });
                addToMistakes(currentQuestion, 'sound');
                speakText('å†è¯•è¯•å§');
            }

            saveStats();

            // 1.5ç§’åä¸‹ä¸€é¢˜
            setTimeout(() => startGame(), 1500);
        }

        function practiceMistakes() {
            currentChars = soundMistakes.map(m => typeof m === 'object' ? m.text : m);
            document.getElementById('charInput').value = currentChars.join(' ');
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.practice-section').forEach(s => s.classList.remove('active'));
            document.querySelector('[data-tab="sound"]').classList.add('active');
            document.getElementById('sound-section').classList.add('active');
            updateSoundSection();
        }

        // æ›´æ–°é”™é¢˜é›†
        function updateMistakesSection() {
            const container = document.getElementById('mistakes-content');

            const totalMistakes = dictationMistakes.length + soundMistakes.length;
            if (totalMistakes === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="emoji">âœ¨</div>
                        <p>æš‚æ—¶æ²¡æœ‰é”™é¢˜ï¼Œç»§ç»­åŠ æ²¹ï¼</p>
                    </div>
                `;
                return;
            }

            let html = '';

            // æ˜¾ç¤ºçœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜
            if (dictationMistakes.length > 0) {
                html += `
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #667eea; font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            âœï¸ çœ‹å­—é€‰æ‹¼éŸ³é”™é¢˜ (${dictationMistakes.length})
                        </h3>
                `;

                // æŒ‰é”™è¯¯æ¬¡æ•°æ’åº
                const sortedMistakes = [...dictationMistakes].sort((a, b) => {
                    const countA = typeof a === 'object' ? a.count : 1;
                    const countB = typeof b === 'object' ? b.count : 1;
                    return countB - countA;
                });

                html += '<div class="mistake-list">';
                sortedMistakes.forEach((item, idx) => {
                    const text = typeof item === 'object' ? item.text : item;
                    const count = typeof item === 'object' ? item.count : 1;
                    const lastWrong = typeof item === 'object' && item.lastWrong ? new Date(item.lastWrong).toLocaleString('zh-CN') : '';
                    const pinyin = getPinyin(text);

                    // æ‰¾åˆ°åŸå§‹ç´¢å¼•ç”¨äºåˆ é™¤
                    const originalIdx = dictationMistakes.indexOf(item);

                    html += `
                        <div class="mistake-item">
                            <div style="flex: 1;">
                                <span class="char">${escapeHtml(text)}</span>
                                <span class="info">${escapeHtml(pinyin)}</span>
                                <span class="info" style="margin-left: 10px; color: #eb3349;">âŒ é”™è¯¯ ${count} æ¬¡</span>
                                ${lastWrong ? `<span class="info" style="margin-left: 10px; color: #999; font-size: 0.85em;">${lastWrong}</span>` : ''}
                            </div>
                            <button class="remove-btn" onclick="removeFromMistakes(${originalIdx}, 'dictation')">ç§»é™¤</button>
                        </div>
                    `;
                });
                html += '</div>';

                const totalErrors = dictationMistakes.reduce((sum, m) => sum + (typeof m === 'object' ? m.count : 1), 0);
                html += `<p style="text-align: center; color: #666; margin-top: 10px;">ç´¯è®¡é”™è¯¯ ${totalErrors} æ¬¡</p>`;

                html += `</div>`;
            }

            // æ˜¾ç¤ºå¬éŸ³é€‰å­—é”™é¢˜
            if (soundMistakes.length > 0) {
                html += `
                    <div style="margin-bottom: 25px;">
                        <h3 style="color: #764ba2; font-size: 1.3em; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            ğŸ‘‚ å¬éŸ³é€‰å­—é”™é¢˜ (${soundMistakes.length})
                        </h3>
                `;

                // æŒ‰é”™è¯¯æ¬¡æ•°æ’åº
                const sortedMistakes = [...soundMistakes].sort((a, b) => {
                    const countA = typeof a === 'object' ? a.count : 1;
                    const countB = typeof b === 'object' ? b.count : 1;
                    return countB - countA;
                });

                html += '<div class="mistake-list">';
                sortedMistakes.forEach((item, idx) => {
                    const text = typeof item === 'object' ? item.text : item;
                    const count = typeof item === 'object' ? item.count : 1;
                    const lastWrong = typeof item === 'object' && item.lastWrong ? new Date(item.lastWrong).toLocaleString('zh-CN') : '';
                    const pinyin = getPinyin(text);

                    // æ‰¾åˆ°åŸå§‹ç´¢å¼•ç”¨äºåˆ é™¤
                    const originalIdx = soundMistakes.indexOf(item);

                    html += `
                        <div class="mistake-item">
                            <div style="flex: 1;">
                                <span class="char">${escapeHtml(text)}</span>
                                <span class="info">${escapeHtml(pinyin)}</span>
                                <span class="info" style="margin-left: 10px; color: #eb3349;">âŒ é”™è¯¯ ${count} æ¬¡</span>
                                ${lastWrong ? `<span class="info" style="margin-left: 10px; color: #999; font-size: 0.85em;">${lastWrong}</span>` : ''}
                            </div>
                            <button class="remove-btn" onclick="removeFromMistakes(${originalIdx}, 'sound')">ç§»é™¤</button>
                        </div>
                    `;
                });
                html += '</div>';

                const totalErrors = soundMistakes.reduce((sum, m) => sum + (typeof m === 'object' ? m.count : 1), 0);
                html += `<p style="text-align: center; color: #666; margin-top: 10px;">ç´¯è®¡é”™è¯¯ ${totalErrors} æ¬¡</p>`;

                html += `<button class="btn btn-primary" onclick="practiceMistakes()" style="margin-top: 15px; padding: 12px 30px; border: none; border-radius: 25px; font-size: 1em; font-weight: bold; cursor: pointer; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">ğŸ® ç»ƒä¹ å¬éŸ³é”™é¢˜</button>`;

                html += `</div>`;
            }

            container.innerHTML = html;
        }

        // æ›´æ–°ç»Ÿè®¡
        function updateStatsSection() {
            document.getElementById('totalLearned').textContent = stats.totalLearned || 0;
            document.getElementById('totalPractice').textContent = stats.totalPractice || 0;
            const rate = stats.totalPractice > 0 ? Math.round((stats.correctCount / stats.totalPractice) * 100) : 0;
            document.getElementById('correctRate').textContent = rate + '%';
            document.getElementById('mistakeCount').textContent = getMistakesCount();

            // æ˜¾ç¤ºå·²å­¦å­—è¯åˆ—è¡¨
            const listContainer = document.getElementById('learnedWordsList');
            if (stats.learnedWords && stats.learnedWords.length > 0) {
                const lastPractice = stats.lastPractice ? new Date(stats.lastPractice).toLocaleString('zh-CN') : 'æš‚æ— è®°å½•';
                let html = `
                    <div style="background: #f0f8ff; padding: 15px; border-radius: 10px;">
                        <p style="color: #666; margin-bottom: 10px;">ğŸ• æœ€åç»ƒä¹ ï¼š${lastPractice}</p>
                    </div>
                    <div style="background: #fff9e6; padding: 15px; border-radius: 10px; margin-top: 10px;">
                        <h3 style="color: #667eea; margin-bottom: 10px; font-size: 1.1em;">ğŸ“š å·²å­¦å­—è¯åˆ—è¡¨</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                `;
                stats.learnedWords.slice().reverse().forEach(word => {
                    html += `<span style="background: white; padding: 6px 12px; border-radius: 15px; font-size: 0.95em; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">${escapeHtml(word)}</span>`;
                });
                html += `
                        </div>
                    </div>
                `;
                listContainer.innerHTML = html;
            } else {
                listContainer.innerHTML = `<p style="text-align: center; color: #999; padding: 20px;">è¿˜æ²¡æœ‰å­¦ä¹ è®°å½•ï¼Œå¼€å§‹å­¦ä¹ å§ï¼</p>`;
            }
        }

        // è¯­éŸ³åŠŸèƒ½
        function speakText(text) {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.8;
                speechSynthesis.speak(utterance);
            }
        }

        // åˆå§‹åŒ–ç»Ÿè®¡æ˜¾ç¤º
        updateStatsSection();

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
        window.addEventListener('load', () => {
            if (stats.totalPractice > 0) {
                const lastTime = stats.lastPractice ? new Date(stats.lastPractice).toLocaleString('zh-CN') : '';
                setTimeout(() => {
                    speakText(`æ¬¢è¿å›æ¥ï¼ä½ å·²ç»ç»ƒä¹ äº†${stats.totalPractice}æ¬¡ï¼Œç»§ç»­åŠ æ²¹ï¼`);
                }, 500);
            }
        });
    </script>
</body>
</html>
